<!DOCTYPE html>
<html lang="es" class="bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos personalizados y animaciones */
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilo para la barra de progreso */
        progress[value]::-webkit-progress-bar {
            background-color: #4a5568;
            border-radius: 9999px;
        }
        progress[value]::-webkit-progress-value {
            background-color: #f6ad55;
            border-radius: 9999px;
            transition: width 0.1s linear;
        }
        .player-shadow {
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="text-white">

    <!-- Contenedor principal de la aplicación -->
    <div id="app-container" class="pb-40"> <!-- Padding bottom para dejar espacio al reproductor -->

        <!-- Vista: Mis Podcasts -->
        <div id="podcasts-view" class="p-4">
            <h1 class="text-3xl font-bold mb-6 text-orange-400">Mis Podcasts</h1>
            <div id="podcasts-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                <!-- Las carátulas de los podcasts se insertarán aquí -->
            </div>
            <div id="podcasts-loader" class="hidden text-center py-10">
                <p>Cargando podcasts por primera vez...</p>
            </div>
            <div id="podcasts-error" class="hidden text-center py-10 bg-red-900/50 rounded-lg">
                <p>Error al cargar los podcasts. Revisa tu conexión.</p>
            </div>
        </div>

        <!-- Vista: Episodios de un Podcast -->
        <div id="episodes-view" class="hidden p-4 fade-in">
            <button id="back-to-podcasts" class="mb-4 text-orange-400 font-semibold">&larr; Volver</button>
            <div id="podcast-header" class="text-center mb-6">
                <!-- La información del podcast seleccionado se insertará aquí -->
            </div>
            <h2 class="text-2xl font-bold mb-4">Episodios</h2>
            <div id="episodes-list">
                <!-- La lista de episodios se insertará aquí -->
            </div>
            <div id="episodes-loader" class="text-center py-10">
                <p>Cargando episodios...</p>
            </div>
             <div id="episodes-error" class="hidden text-center py-10 bg-red-900/50 rounded-lg">
                <p>No se pudo cargar el feed RSS de este podcast.</p>
            </div>
        </div>
    </div>

    <!-- Reproductor de Audio Fijo -->
    <div id="player" class="hidden fixed bottom-0 left-0 right-0 bg-gray-800 border-t border-gray-700 p-3 player-shadow fade-in">
        <div class="flex items-center mb-2">
            <img id="player-artwork" src="https://placehold.co/60x60/1a202c/ffffff?text=?" class="w-14 h-14 rounded-md mr-3" alt="Carátula del episodio">
            <div class="flex-grow overflow-hidden">
                <p id="player-episode-title" class="font-bold text-sm truncate">Título del episodio</p>
                <p id="player-podcast-title" class="text-xs text-gray-400">Nombre del Podcast</p>
            </div>
        </div>
         <div class="w-full mb-2">
            <progress id="player-progress" value="0" max="100" class="w-full h-1.5"></progress>
        </div>
        <div class="flex justify-center items-center space-x-6">
             <button id="player-rewind" class="p-2">
                <!-- Icono de retroceder se insertará aquí -->
            </button>
            <button id="player-play-pause" class="p-2 bg-orange-500 rounded-full">
                <!-- Icono de Play/Pausa se insertará aquí -->
            </button>
             <button id="player-forward" class="p-2">
                <!-- Icono de avanzar se insertará aquí -->
            </button>
        </div>
    </div>

    <!-- Elemento de audio (oculto) -->
    <audio id="audio-element"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- ELEMENTOS DEL DOM ---
            const podcastsView = document.getElementById('podcasts-view');
            const episodesView = document.getElementById('episodes-view');
            const podcastsGrid = document.getElementById('podcasts-grid');
            const episodesList = document.getElementById('episodes-list');
            const podcastHeader = document.getElementById('podcast-header');
            const backToPodcastsBtn = document.getElementById('back-to-podcasts');
            const podcastsLoader = document.getElementById('podcasts-loader');
            const episodesLoader = document.getElementById('episodes-loader');
            const podcastsErrorEl = document.getElementById('podcasts-error');
            const episodesErrorEl = document.getElementById('episodes-error');
            const player = document.getElementById('player');
            const audioElement = document.getElementById('audio-element');
            const playerArtwork = document.getElementById('player-artwork');
            const playerEpisodeTitle = document.getElementById('player-episode-title');
            const playerPodcastTitle = document.getElementById('player-podcast-title');
            const playerPlayPauseBtn = document.getElementById('player-play-pause');
            const playerRewindBtn = document.getElementById('player-rewind');
            const playerForwardBtn = document.getElementById('player-forward');
            const playerProgress = document.getElementById('player-progress');

            // --- DATOS Y ESTADO ---
            const CORS_PROXY = "https://api.allorigins.win/raw?url=";
            const podcasts = [
                { name: "A dos bandas", rssUrl: "https://www.omnycontent.com/d/playlist/7e594858-42ba-4ecb-86d8-ad1a002e5281/1d39fbf3-b41a-4c54-88ec-adcd0136c774/df3205fa-ee92-4df4-9308-adcd0136c791/podcast.rss" },
                { name: "Brazalete Negro", rssUrl: "https://www.primaverasound.com/radio/shows/brazalete-negro?action=rss" },
                { name: "El Larguero", rssUrl: "https://fapi-top.prisasd.com/podcast/playser/el_larguero/itunestfp/podcast.xml" },
                { name: "El Morning de Axel y Rulo", rssUrl: "https://www.ivoox.com/feed_fg_f1305937_filtro_1.xml" },
                { name: "El Partidazo de COPE", rssUrl: "https://www.cope.es/api/es/programas/el-partidazo-de-cope/audios/rss.xml" },
                { name: "La Libreta de Van Gaal", rssUrl: "https://feeds.megaphone.fm/LALIBRETA2492905101" },
                { name: "La Pizarra de Quintana", rssUrl: "https://www.omnycontent.com/d/playlist/4ac2c3a8-bb0c-499b-bf22-ac8400df1983/23858072-d78f-4b2c-870e-ad95016caf18/272fdbf7-9428-4781-92e9-ad95016eb929/podcast.rss" },
                { name: "La Tribu con Raúl Varela", rssUrl: "https://www.omnycontent.com/d/playlist/4ac2c3a8-bb0c-499b-bf22-ac8400df1983/7345e2c8-3edf-4530-b882-ac8700b152e1/a6c99e71-a9ce-48d3-97d9-acaa0101581c/podcast.rss" },
                { name: "Offsiders", rssUrl: "https://feeds.megaphone.fm/HOT2717170364" },
                { name: "Tertulia Blanquinegra - Efesista APP", rssUrl: "https://www.ivoox.com/feed_fg_f1156320_filtro_1.xml" },
                { name: "Tiempo de Juego", rssUrl: "https://www.cope.es/api/es/programas/tiempo-de-juego/audios/rss.xml" },
                { name: "¡El Chiringuito de Jugones!", rssUrl: "https://www.ivoox.com/feed_fg_f11226820_filtro_1.xml" }
            ];
            
            let sessionCache = new Map();

            // --- ICONOS SVG ---
            const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
            const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
            const rewindIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><path d="M16 12h-8"></path></svg>`;
            const forwardIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 8 16 12 12 16"></polyline><path d="M8 12h8"></path></svg>`;
            
            playerRewindBtn.innerHTML = rewindIcon;
            playerForwardBtn.innerHTML = forwardIcon;

            // --- FUNCIONES PRINCIPALES ---

            async function fetchAndParseRSS(rssUrl) {
                if (sessionCache.has(rssUrl)) return sessionCache.get(rssUrl);

                try {
                    const response = await fetch(`${CORS_PROXY}${encodeURIComponent(rssUrl)}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    const text = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(text, "application/xml");

                    const parseError = xmlDoc.querySelector("parsererror");
                    if (parseError) { throw new Error("Failed to parse RSS feed."); }

                    const title = xmlDoc.querySelector("channel > title")?.textContent || "Sin título";
                    const artworkUrl = xmlDoc.querySelector("channel > image > url")?.textContent || xmlDoc.querySelector("channel > itunes\\:image, channel > image")?.getAttribute("href") || "https://placehold.co/300x300/1a202c/ffffff?text=Podcast";
                    
                    const episodes = Array.from(xmlDoc.querySelectorAll("channel > item")).map(item => ({
                        title: item.querySelector("title")?.textContent || "Episodio sin título",
                        pubDate: new Date(item.querySelector("pubDate")?.textContent || ""),
                        description: (item.querySelector("description, content\\:encoded")?.textContent || "Sin descripción.").replace(/<[^>]*>/g, '').substring(0, 120) + '...',
                        audioUrl: item.querySelector("enclosure")?.getAttribute("url") || "",
                    })).filter(ep => ep.audioUrl).sort((a, b) => b.pubDate - a.pubDate);
                        
                    const podcastData = { title, artworkUrl, episodes };
                    sessionCache.set(rssUrl, podcastData);
                    return podcastData;

                } catch (error) {
                    console.error(`Error fetching RSS feed ${rssUrl}:`, error);
                    return null;
                }
            }

            async function renderPodcastsView() {
                showView('podcasts');
                podcastsGrid.innerHTML = '';
                podcastsErrorEl.classList.add('hidden');
                
                let metadataCache = JSON.parse(localStorage.getItem('podcastMetadataCache')) || {};

                if (Object.keys(metadataCache).length === 0) {
                    podcastsLoader.classList.remove('hidden');
                }

                podcasts.forEach(podcast => {
                    const cachedInfo = metadataCache[podcast.rssUrl];
                    const card = document.createElement('div');
                    card.className = 'fade-in';
                    card.dataset.rssUrl = podcast.rssUrl;
                    const artwork = cachedInfo ? cachedInfo.artworkUrl : 'https://placehold.co/300x300/1a202c/ffffff?text=...';
                    const title = cachedInfo ? cachedInfo.title : podcast.name;

                    card.innerHTML = `
                        <img src="${artwork}" alt="${title}" class="w-full h-auto rounded-lg shadow-lg aspect-square object-cover cursor-pointer transition-transform duration-300 hover:scale-105" onerror="this.onerror=null;this.src='https://placehold.co/300x300/1a202c/ff0000?text=Error';">
                        <p class="text-center mt-2 font-semibold text-sm truncate">${title}</p>
                    `;
                    card.querySelector('img').addEventListener('click', () => renderEpisodesView(podcast.rssUrl));
                    podcastsGrid.appendChild(card);
                });

                const updatePromises = podcasts.map(async (podcast) => {
                    if (!metadataCache[podcast.rssUrl] || metadataCache[podcast.rssUrl].artworkUrl.includes('placehold')) {
                        const feedData = await fetchAndParseRSS(podcast.rssUrl);
                        if (feedData) {
                            const metadata = { title: feedData.title, artworkUrl: feedData.artworkUrl };
                            metadataCache[podcast.rssUrl] = metadata;
                            const cardToUpdate = podcastsGrid.querySelector(`[data-rss-url="${podcast.rssUrl}"]`);
                            if (cardToUpdate) {
                                cardToUpdate.querySelector('img').src = metadata.artworkUrl;
                                cardToUpdate.querySelector('p').textContent = metadata.title;
                            }
                        }
                    }
                });

                Promise.allSettled(updatePromises).then(() => {
                    localStorage.setItem('podcastMetadataCache', JSON.stringify(metadataCache));
                    podcastsLoader.classList.add('hidden');
                });
            }

            async function renderEpisodesView(rssUrl) {
                showView('episodes');
                episodesLoader.classList.remove('hidden');
                episodesErrorEl.classList.add('hidden');
                podcastHeader.innerHTML = '';
                episodesList.innerHTML = '';

                const data = await fetchAndParseRSS(rssUrl);

                if (!data) {
                    episodesLoader.classList.add('hidden');
                    episodesErrorEl.classList.remove('hidden');
                    return;
                }

                podcastHeader.innerHTML = `
                    <img src="${data.artworkUrl}" alt="${data.title}" class="w-32 h-32 mx-auto rounded-lg shadow-xl mb-3">
                    <h1 class="text-2xl font-bold">${data.title}</h1>
                `;

                if (data.episodes && data.episodes.length > 0) {
                    data.episodes.forEach(episode => {
                        const episodeEl = document.createElement('div');
                        episodeEl.className = 'p-3 mb-2 bg-gray-800 rounded-lg cursor-pointer hover:bg-gray-700 transition-colors duration-200';
                        episodeEl.innerHTML = `
                            <p class="font-bold">${episode.title}</p>
                            <p class="text-xs text-gray-400 mt-1">${episode.pubDate.toLocaleDateString()}</p>
                            <p class="text-sm text-gray-300 mt-2">${episode.description}</p>
                        `;
                        episodeEl.addEventListener('click', () => playEpisode(episode, data, rssUrl));
                        episodesList.appendChild(episodeEl);
                    });
                } else {
                     episodesList.innerHTML = `<p class="text-center text-gray-400">No se encontraron episodios.</p>`;
                }
                episodesLoader.classList.add('hidden');
            }

            function playEpisode(episode, podcastData, rssUrl) {
                audioElement.src = episode.audioUrl;
                audioElement.dataset.rssUrl = rssUrl;
                audioElement.play();
                player.classList.remove('hidden');
                playerEpisodeTitle.textContent = episode.title;
                playerPodcastTitle.textContent = podcastData.title;
                playerArtwork.src = podcastData.artworkUrl;
                updateMediaSession(episode, podcastData);
            }

            function showView(viewName) {
                podcastsView.classList.toggle('hidden', viewName !== 'podcasts');
                episodesView.classList.toggle('hidden', viewName !== 'episodes');
                if (viewName === 'episodes') window.scrollTo(0, 0);
            }

            /**
             * Actualiza el estado de la posición para el widget de Android.
             */
            function updatePositionState() {
                if ('mediaSession' in navigator && audioElement.duration) {
                    navigator.mediaSession.setPositionState({
                        duration: audioElement.duration,
                        playbackRate: audioElement.playbackRate,
                        position: audioElement.currentTime,
                    });
                }
            }

            function updateMediaSession(episode, podcastData) {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: episode.title,
                        artist: podcastData.title,
                        album: 'Podcasts',
                        artwork: [{ src: podcastData.artworkUrl, sizes: '512x512', type: 'image/png' }]
                    });
                    
                    navigator.mediaSession.setActionHandler('play', () => audioElement.play());
                    navigator.mediaSession.setActionHandler('pause', () => audioElement.pause());
                    navigator.mediaSession.setActionHandler('seekbackward', (details) => { audioElement.currentTime = Math.max(0, audioElement.currentTime - (details.seekOffset || 15)); });
                    navigator.mediaSession.setActionHandler('seekforward', (details) => { audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + (details.seekOffset || 30)); });
                    navigator.mediaSession.setActionHandler('seekto', (details) => { audioElement.currentTime = details.seekTime; });

                    navigator.mediaSession.setActionHandler('previoustrack', null);
                    navigator.mediaSession.setActionHandler('nexttrack', null);

                    navigator.mediaSession.setActionHandler('stop', () => {
                        audioElement.pause();
                        audioElement.currentTime = 0;
                        player.classList.add('hidden');
                        localStorage.removeItem('playbackState');
                    });
                }
            }
            
            async function restorePlaybackState() {
                const savedStateJSON = localStorage.getItem('playbackState');
                if (!savedStateJSON) return;

                const savedState = JSON.parse(savedStateJSON);
                if (!savedState.rssUrl || !savedState.audioUrl) return;

                const podcastData = await fetchAndParseRSS(savedState.rssUrl);
                if (!podcastData || !podcastData.episodes) return;

                const episodeToRestore = podcastData.episodes.find(ep => ep.audioUrl === savedState.audioUrl);
                if (!episodeToRestore) {
                    localStorage.removeItem('playbackState');
                    return;
                }

                audioElement.src = episodeToRestore.audioUrl;
                audioElement.dataset.rssUrl = savedState.rssUrl;
                
                audioElement.addEventListener('loadedmetadata', () => {
                    audioElement.currentTime = savedState.currentTime;
                    updatePositionState();
                    if (audioElement.duration) {
                        playerProgress.value = (audioElement.currentTime / audioElement.duration) * 100;
                    }
                }, { once: true });

                player.classList.remove('hidden');
                playerEpisodeTitle.textContent = episodeToRestore.title;
                playerPodcastTitle.textContent = podcastData.title;
                playerArtwork.src = podcastData.artworkUrl;
                playerPlayPauseBtn.innerHTML = playIcon;
                
                updateMediaSession(episodeToRestore, podcastData);
            }

            // --- EVENT LISTENERS ---
            backToPodcastsBtn.addEventListener('click', () => renderPodcastsView());
            playerPlayPauseBtn.addEventListener('click', () => {
                if (audioElement.paused) audioElement.play();
                else audioElement.pause();
            });
            playerRewindBtn.addEventListener('click', () => {
                audioElement.currentTime = Math.max(0, audioElement.currentTime - 15);
            });
            playerForwardBtn.addEventListener('click', () => {
                audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + 30);
            });

            audioElement.addEventListener('play', () => {
                playerPlayPauseBtn.innerHTML = pauseIcon;
                if ('mediaSession' in navigator) navigator.mediaSession.playbackState = "playing";
            });
            audioElement.addEventListener('pause', () => {
                playerPlayPauseBtn.innerHTML = playIcon;
                if ('mediaSession' in navigator) navigator.mediaSession.playbackState = "paused";
            });

            let lastSaveTime = 0;
            audioElement.addEventListener('timeupdate', () => {
                if (audioElement.duration) {
                    playerProgress.value = (audioElement.currentTime / audioElement.duration) * 100;
                    updatePositionState(); // <-- SOLUCIÓN PARA LA BARRA DE PROGRESO DEL WIDGET
                    const now = Date.now();
                    if (now - lastSaveTime > 3000) {
                        const state = {
                            rssUrl: audioElement.dataset.rssUrl,
                            audioUrl: audioElement.src,
                            currentTime: audioElement.currentTime
                        };
                        if(state.rssUrl) localStorage.setItem('playbackState', JSON.stringify(state));
                        lastSaveTime = now;
                    }
                }
            });
            audioElement.addEventListener('ended', () => {
                player.classList.add('hidden');
                localStorage.removeItem('playbackState');
            });

            // --- INICIALIZACIÓN ---
            renderPodcastsView();
            restorePlaybackState();
        });
    </script>
</body>
</html>
